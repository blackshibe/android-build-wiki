{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#welcome-to-the-android-bringup-wiki","title":"Welcome to the Android Bringup Wiki","text":"<p>Info</p> <p>As of writing, Android 15 is the latest Android version.</p> <p>This wiki is meant to provide useful resources for getting whatever ROM you're working on running smoothly. You can view different subpages via the sidebar, or with the search function.</p> <p>Contributors welcome:</p> <ul> <li>If you found any of the information on here helpful, try to contribute back in the future! </li> <li>If something is unclear, open an issue on the Github.</li> </ul> <p>You can start out here</p>"},{"location":"starting_out/","title":"Starting out","text":"<p>Info</p> <p>Last Updated for: Android 14</p>"},{"location":"starting_out/#general-requirements","title":"General requirements","text":"<p>You need to be decent at using Linux &amp; development tools like Git, capable of solving problems on your own, comfortable with a commandline, and knowledgeable with flashing custom ROMs. Builds are slow, debugging is difficult. The list of languages and tools Android as a whole uses is so long it's not worth listing.</p> <p>Android also takes a lot of resources to compile. At bare minimum, you need:</p> <ul> <li>A linux installation - VM or bare metal, preferrably Ubuntu</li> <li>A reasonably fast CPU</li> <li>500GB of free disk space</li> <li>16GB of RAM (with a massive swapfile)</li> </ul>"},{"location":"starting_out/#figure-out-whether-your-device-has-existing-work-done","title":"Figure out whether your device has existing work done","text":"<p>Device dev support is on a (rough) scale from:</p> <ul> <li>Official (Builds directly downloadable from the LineageOS website, for example, with high reliability)</li> <li>Unofficial (XDA threads, or Telegram groups related to the device, may have some issues)</li> <li>WIP trees (Device tree repos on the internet, no actually working builds)</li> <li>No trees</li> <li>No trees and no kernel</li> </ul> <p>If you're new you should start out with a device with either official or unofficial builds. To start your first compilation, you need to find the following things for your device:</p> <ul> <li>A device tree (example)<ul> <li>A repository with makefiles and configurations that specifies everything about the device.</li> </ul> </li> <li>A kernel (example)<ul> <li>Android devices don't run mainline Linux. Each device has its' own manufacturer-developed kernel released somewhere, unless the manufacturer is breaking the GPL license.</li> </ul> </li> <li>Vendor blobs (example)<ul> <li>Every device needs proprietary blobs for things ranging from the camera to custom built-in apps.</li> </ul> </li> </ul> <p>Vendor blobs can be extracted from a device running a working ROM if you can't find a repository with them. LineageOS does not store them at all for example, and part of their build instructions is pulling the files from a device already running LineageOS.</p> <p>XDA threads for ROMs usually link all of these - Example</p> <p>If you have official ROM support, you may find them under the organization of the ROM that supports your device officially.</p> <p>If you can't find a device tree, you're out of luck.</p>"},{"location":"starting_out/#set-up-repo-get-to-syncing","title":"Set up repo, get to syncing","text":"<p>Info</p> <p>This part of the guide is from the crDroid build manifest</p> <p>Repo is a tool provided by Google that simplifies using Git in the context of the Android source.</p>"},{"location":"starting_out/#install-dependencies","title":"Install dependencies","text":"Text Only<pre><code>sudo apt install bc bison build-essential ccache curl flex g++-multilib gcc-multilib git git-lfs gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev liblz4-tool libncurses5 libncurses5-dev libsdl1.2-dev libssl-dev libwxgtk3.0-gtk3-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev\n</code></pre> <p>If some are missing (in the future), find replacements or continue anyway. Compilation won't succeed or give you more useful specific errors as to what you're missing if you're short on needed packages.</p>"},{"location":"starting_out/#install-repo-tool","title":"Install Repo tool","text":"Bash<pre><code># Make a directory where Repo will be stored and add it to the path\n$ mkdir ~/bin\n$ PATH=~/bin:$PATH\n\n# Download Repo itself\n$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo\n\n# Make Repo executable\n$ chmod a+x ~/bin/repo\n</code></pre>"},{"location":"starting_out/#initialize-repo","title":"Initialize repo","text":"<p>You're going to want to find the build manifest for the ROM and the ROM version you're building. In this example, LineageOS.</p> Bash<pre><code># Create a directory for the source files\n# This can be located anywhere (as long as the fs is case-sensitive)\n$ mkdir my-rom\n$ cd my-rom\n\n# the manifest tells you what to clone\nrepo init -u https://github.com/LineageOS/android.git -b lineage-21.0 --git-lfs\n</code></pre>"},{"location":"starting_out/#sync","title":"Sync","text":"<p>This is what you will run each time you want to pull in upstream changes. Keep in mind that on your first run, it is expected to take a while as it will download all the required Android source files and their change histories.</p> Bash<pre><code># Let Repo take care of all the hard work\n# This always downloads the latest changes from all repos, skipping repositories with uncommited changes\n$ repo sync\n</code></pre>"},{"location":"starting_out/#initialize-build-manifest","title":"Initialize build manifest","text":"<p>The .repo folder has manifests, and those manifests tell repo what to download. You will need a local one for device-specific things. Assuming the folder you created for the ROM is <code>my-rom</code>, make a folder in <code>my-rom/.repo/local_manifests</code>, and make a file called <code>my-rom/.repo/local_manifests/manifest.xml</code>.</p> <p>Example contents: XML<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;manifest&gt;\n    &lt;!-- Remotes are places you get repositories from. The name is arbitrary --&gt;\n    &lt;remote name=\"blackshibe\" fetch=\"https://github.com/blackshibe\"/&gt;\n    &lt;remote name=\"LineageOS\" fetch=\"https://github.com/LineageOS\"/&gt;\n\n    &lt;!-- The device tree as mentioned above. This one is commonized, meaning non-device specific changes are in another repo (sm8550-common) --&gt;\n    &lt;project path=\"device/sony/pdx234\" name=\"android_device_sony_pdx234\" remote=\"blackshibe\" revision=\"lineage-21\" /&gt;\n\n    &lt;!-- path is the path the repo will be cloned to, name is the name of the repository, the remote is the remote from above, revision is the branch  --&gt;\n    &lt;project path=\"device/sony/sm8550-common\" name=\"android_device_sony_sm8550-common\" remote=\"blackshibe\" revision=\"lineage-21\" /&gt;\n\n    &lt;!-- Device kernel. Sometimes you need additional repos related --&gt;\n    &lt;project path=\"kernel/sony/sm8550\" name=\"android_kernel_sony_sm8550\" remote=\"LineageOS\" revision=\"lineage-21\" /&gt;\n    &lt;project path=\"kernel/sony/sm8550-devicetrees\" name=\"android_kernel_sony_sm8550-devicetrees\" remote=\"LineageOS\" revision=\"lineage-21\" /&gt;\n    &lt;project path=\"kernel/sony/sm8550-modules\" name=\"android_kernel_sony_sm8550-modules\" remote=\"LineageOS\" revision=\"lineage-21\" /&gt;\n\n    &lt;!-- Vendor files. These are commonized as well to match the device trees --&gt;\n    &lt;project path=\"vendor/sony/pdx234\" name=\"proprietary_vendor_sony_pdx234\" remote=\"blackshibe\" revision=\"lineage-21\" /&gt;\n    &lt;project path=\"vendor/sony/sm8550-common\" name=\"proprietary_vendor_sony_sm8550-common\" remote=\"blackshibe\" revision=\"lineage-21\" /&gt;\n\n    &lt;!-- You can also delete projects from the main build manifest --&gt;\n    &lt;!-- &lt;remove-project name=\"frameworks/base\" /&gt; --&gt;\n&lt;/manifest&gt;\n</code></pre></p> <p>Once this is done run repo sync again. It will tell you if any repos are defined incorrectly. Once they are all there, proceed</p>"},{"location":"starting_out/#build","title":"Build","text":""},{"location":"starting_out/#for-devices-officially-supported-by-the-rom-youre-building","title":"For devices officially supported by the ROM you're building:","text":"Bash<pre><code># Run to prepare our devices list\n$ . build/envsetup.sh\n# ... now run\n$ brunch devicecodename\n</code></pre>"},{"location":"starting_out/#for-other-devices","title":"For other devices","text":"<p>Your device tree will have a primary makefile. Lineage uses <code>lineage_CODENAME.mk</code> In the example above, it is <code>lineage_pdx234.mk</code>. You need this for the build target</p> Bash<pre><code># Prepare build\n$ . build/envsetup.sh\n# Run build. Format is device-release-type, \n$ brunch lineage_pdx234-ap2a-eng\n</code></pre> <p>ap2a means 14 QPR3. ap3a is 15. Eng build type enables adb on boot and various debugging features in recovery and system as well as disabling a lot of optimizations. You should build userdebug and user once the ROM works fine</p>"},{"location":"starting_out/#result","title":"Result","text":"<p>Once done, the files are in <code>out/target/product/CODENAME</code>. You will want to flash and to start debugging your build</p>"},{"location":"useful_resources/","title":"Useful resources","text":"<p>Info</p> <p>Last Updated for: Android 14</p>"},{"location":"useful_resources/#telegram-chats","title":"Telegram chats","text":"<ul> <li>t.me/AndroidBuildersHelp</li> <li>t.me/alaskalinuxuser_romdevelopment</li> <li>t.me/build_twrp</li> </ul> <p>The people there generally don't like having their time wasted. Provide actual error info and be patient to get any help.</p>"},{"location":"useful_resources/#basics","title":"Basics","text":"<p>Android has its own official documentation: https://source.android.google.cn/  I suggest reading all of it.</p>"},{"location":"useful_resources/#weblinks","title":"Weblinks","text":"<ul> <li>LineageOS debugging crash course</li> <li>Signing builds correctly</li> <li>AlaskaLinuxUser on Youtube - decent youtube tutorials</li> <li>Some Chinese dude's tutorial on A/B:</li> <li>twrpdtgen; useful tool for compiling a device tree from scratch: https://github.com/twrpdtgen/twrpdtgen</li> <li>PostMarketOS wiki has great developer guides</li> </ul>"},{"location":"useful_resources/#sony-devices","title":"Sony devices","text":"<ul> <li>SODP is a \"good\" starting point for building ROMs</li> <li>XperiFirm; tool for downloading OTA xperia firmware</li> <li>newflasher; tool for flashing firmware to recent Sony devices</li> </ul>"},{"location":"advanced/proprietary_files/","title":"Proprietary files","text":"<p>Info</p> <p>Last Updated for: Android 15</p> <p><code>proprietary-files.txt</code> is a list of proprietary libraries (called blobs) that need to be pulled from stock device firmware to be used in your custom ROM. They are used with scripts <code>extract-files.py</code> and <code>setup-makefiles.py</code> (or *.sh for LineageOS older than 22.0) to generate makefiles and soong files in <code>vendor</code>.</p>"},{"location":"advanced/proprietary_files/#dumping-firmware","title":"Dumping firmware","text":"<p>You shouldn't make edits to the generated vendor folder. Instead, any changes should be made to <code>proprietary-files.txt</code> and <code>extract-files.py</code>.</p> <p>You can run <code>extract-files.py</code> either with an ADB device connected, or with <code>extract-files.py /path/to/firmware/folder</code>. This will pull the files from the source to the vendor folder. It will also tell you about any errors.</p> <p>You will know about missing libraries either from soong library checks, make errors or dlopen errors in the build logcat. You can fix them by including the libraries the blobs are asking for from stock firmware.</p>"},{"location":"advanced/proprietary_files/#fixup","title":"Fixup","text":"<p>Some blobs may need fixing when imported, for reasons including Android updates. This is what <code>blob_fixups</code> is for.</p> Python<pre><code>blob_fixups: blob_fixups_user_type = {\n    # Simple file edit\n    'vendor/etc/msm_irqbalance.conf': blob_fixup()\n    .regex_replace('IGNORED_IRQ=27,23,38', 'IGNORED_IRQ=27,23,38,115,332'),\n\n    # Add line to file\n    'vendor/etc/seccomp_policy/qwesd@2.0.policy': blob_fixup()\n    .add_line_if_missing('pipe2: 1')\n    .add_line_if_missing('gettid: 1'),\n\n    # Add lib import to blob\n    'system_ext/lib64/libwfdnative.so': blob_fixup()\n    .add_needed('libinput_shim.so'),\n\n    # Load android.hardware.light-V1-ndk.so instead of android.hardware.light-V1-ndk_platform.so\n    'vendor/lib64/vendor.semc.hardware.extlight-V1-ndk_platform.so': blob_fixup()\n    .replace_needed('android.hardware.light-V1-ndk_platform.so', 'android.hardware.light-V1-ndk.so'),\n}  # fmt: skip\n</code></pre>"},{"location":"advanced/proprietary_files/#shims","title":"Shims","text":"<p>Sometimes blobs may have unresolved symbols due to Android API changes:</p> Text Only<pre><code>[PATH]/libwvhidl.so: error: Unresolved symbol: CBS_init\n[PATH]/libwvhidl.so: note:\n[PATH]/libwvhidl.so: note: Some dependencies might be changed, thus the symbol(s) above cannot be resolved.\n[PATH]/libwvhidl.so: note: Please re-build the prebuilt file: \"[PATH]/libwvhidl.so\".\n[PATH]/libwvhidl.so: note:\n[PATH]/libwvhidl.so: note: If this is a new prebuilt file and it is designed to have unresolved symbols, add one of the following properties:\n[PATH]/libwvhidl.so: note:   Android.bp: allow_undefined_symbols: true,\n[PATH]/libwvhidl.so: note:   Android.mk: LOCAL_ALLOW_UNDEFINED_SYMBOLS := true\n</code></pre> <p>here <code>libwvhidl.so</code> is missing <code>CBS_init</code>. Looking at LineageOS gerrit you can see this file is commonly patched with a LineageOS libcrypto shim - All you need to do is what the patches do, or just to cherry-pick them</p>"},{"location":"advanced/qualcomm_crashdump/","title":"Qualcomm Crashdump","text":"<p>Info</p> <p>Last Updated for: Android 14</p> <p>This is your last resort, if you can't get USB working and/or ADB access; and you're bootlooping. So, some Qualcomm devices have crashdump mode enabled, and this allows us to get a memory dump using EDL, when the kernel panics.</p> <p>In my case, I had to enable dload mode in the kernel:</p> Diff<pre><code>Author: Raghuram Subramani &lt;raghus2247@gmail.com&gt;\nDate:   Wed Oct 16 09:51:00 2024 +0530\n\n    power: reset: msm: Use download mode by default\n\ndiff --git a/drivers/power/reset/msm-poweroff.c b/drivers/power/reset/msm-poweroff.c\nindex f267ec9d..50b5d76d 100644\n--- a/drivers/power/reset/msm-poweroff.c\n+++ b/drivers/power/reset/msm-poweroff.c\n@@ -84,7 +84,7 @@ static struct notifier_block panic_blk = {\n #endif\n\n static int dload_type = SCM_DLOAD_FULLDUMP;\n-static int download_mode;\n+static int download_mode = 1;\n static struct kobject dload_kobj;\n static void *dload_mode_addr, *dload_type_addr;\n static bool dload_mode_enabled;\n</code></pre> <p>To trigger a kernel panic on reboot:</p> Diff<pre><code>Author: Raghuram Subramani &lt;raghus2247@gmail.com&gt;\nDate:   Wed Oct 16 09:54:35 2024 +0530\n\n    kernel: reboot: Panic before restart\n\ndiff --git a/kernel/reboot.c b/kernel/reboot.c\nindex 2946ed1d..aaec620a 100644\n--- a/kernel/reboot.c\n+++ b/kernel/reboot.c\n@@ -221,6 +221,7 @@ void kernel_restart(char *cmd)\n        else\n                pr_emerg(\"Restarting system with command '%s'\\n\", cmd);\n        kmsg_dump(KMSG_DUMP_RESTART);\n+  panic(\"SOMETHINGRANDOMICANSEARCHFOR\");\n        machine_restart(cmd);\n }\n EXPORT_SYMBOL_GPL(kernel_restart);\n</code></pre> <p>Next, compile the kernel and flash it. When reboot is triggered, the kernel panics and the phone reboots into crashdump mode. To dump the kernel, install edl and run:</p> Bash<pre><code>edl memorydump\n</code></pre> <p>This will create a <code>memory/</code> folder, and inside it there will be multiple files. We are concerned with the DDRCSx.bin.</p> <p>First, we can try searching for what requested the reboot:</p> Bash<pre><code>strings DDRCSx.bin | grep reboot | grep request\n</code></pre> <p>If you find something, open the bin file in a text editor, search for the string, and look above it to see what requested the reboot.</p> <p>Alternatively, we can get the dmesg log. To do this, we search for the username of the computer that built the kernel. This is because, the first line of the kernel log contains the username of the builder.</p> Bash<pre><code>strings DDRCSx.bin | grep USERNAME\n</code></pre> <p>Look for this string in the dump, and below it will be the kernel log.</p>"},{"location":"advanced/starting_bringup/","title":"Starting a bringup","text":"<p>Info</p> <p>Last Updated for: Android 15</p> <p>This is a relatively difficult topic with no universal guide for good reason - Your experience will differ significantly whether you're bringing up an MTK or Qualcomm device and whether your manufacturer has released properly working sources or not. Expect errors completely unrelated to your actual issue and a lot of log digging.</p>"},{"location":"advanced/starting_bringup/#gathering-information","title":"Gathering information","text":"<p>As a basis for bringup, you need to know the specifics of your device - The codename, build number, place to find stock firmware, the specs it's running, etc.</p> <p>You will also need to find a: - Kernel source code     - OEMs are required to release their kernel sources according to GPL but they are sometimes late, or break the law. - Stock firmware dump     - You will need this for proprietary blobs and configs, partition and kernel config, build fingerprint, etc - Similiar device tree      - Find one in the following order:         - Same SoC with same manufacturer         - Same SoC         - Different SoC, same brand, same manufacturer</p>"},{"location":"advanced/starting_bringup/#unpacking-boot-image","title":"Unpacking boot image","text":"<p>Bootimage will give you kernel configuration information. AOSP has an unpack bootimg utility</p> <p>Todo</p>"},{"location":"advanced/starting_bringup/#proprietary-filestxt","title":"proprietary-files.txt","text":"<p>There will be a lot of libraries you cannot build from source, which are pulled from the device using proprietary-files.txt. The script that does the extraction is <code>extract-files.sh</code> or <code>extract-files.py</code> depending on your device tree. You can also point it to a folder with a ROM dump (which makes things easier if you don't own the device yourself)</p> <p>More information here</p>"},{"location":"advanced/starting_bringup/#building-kernel","title":"Building kernel","text":"<p>You will need to find a copyleft release of a kernel for your device. Each manufacturer releases it in different places and some don't release full source code. Afterwards, you need to</p> <p>Todo</p>"},{"location":"general/build_errors/","title":"Build Errors","text":"<p>Info</p> <p>Last Updated for: Android 14</p>"},{"location":"general/build_errors/#error-while-loading-shared-libraries-libcryptso1","title":"<code>error while loading shared libraries: libcrypt.so.1</code>","text":"<ul> <li><code>error while loading shared libraries: libcrypt.so.1: cannot open shared object file: No such file or directory</code></li> <li>You're missing SSL libraries locally; install libxcrypt-compat (on arch)</li> </ul>"},{"location":"general/build_errors/#cannot-find-yamlyamlh","title":"<code>cannot find &lt;yaml/yaml.h&gt;</code>","text":"<ul> <li>Make sure yaml-dev headers are installed on your PC</li> <li>If they are, edit <code>build/soong/ui/build/paths/config.go</code> and do this</li> <li>Telegram message link</li> </ul>"},{"location":"general/overlays/","title":"Overlays","text":"<p>Info</p> <p>Last Updated for: Android 14</p> <p>source.android.com reference</p>"},{"location":"general/fstab/fstab/","title":"Fstab","text":"<p>To create the fstab, you can use sebaubuntu's twrpdtgen, which generates a basic device tree. Then, edit the device tree using the newer TWRP device tree template. The fstab is important because it contains information and mount points for your system.</p> <p>twrpdtgen creates the fstab file, but you'll need to add \";backup=1;flashimg\" flags for partitions you want to backup and flash, and \";wipeingui\" flag to the partitions you want to wipe. For partitions you want to flash images to, change ext4 to emmc.</p> <p>For dynamic partitions devices, there is no partition called \"system\", only a partition called \"super\". Unpacking the super.img reveals that it contains the system, vendor, product, and odm partitions. The super partition is acting like a container.</p> <p>If you have a super partition, remove the \"logical\" flag in the system, vendor, product, and odm lines. Then, add the \";wipeingui\" flag, make a copy of the four lines, and rename the copied line's mount points to system_image. Change the ext4 to emmc in the copied lines, and add \"/dev/block/mapper/\" to the beginning of their locations. Remove the \";wipeingui\" from the copied lines and add \";backup=1;flashimg\" flags.</p> <p>After making these modifications, you will be able to backup, wipe, and flash the partitions inside the super partition of your device. Good luck!</p>"}]}